# Java基础部分

## &与&&区别？

*&和&&都是逻辑运算符，都是判断两边同时真则为真，否则为假；但是&&当第一个条件不成之后，后面的条件都不执行了，而&则还是继续执行，直到整个条件语句执行完为止。

## 使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容 还是可以改变的。

## 静态变量和实例变量的区别？

在语法定义上的区别：

静态变量前要加 static 关键字，而实例变量前则不加。

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变 量才会被分配空间，才能使用这个实例变量。

静态变量不属于某个实例对象，而是属于类， 所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

总之，实例变量必须创建对象后才可以通过这个对象 来使用，静态变量则可以直接使用类名来引用。

静态变量使用时,通过类名.名称,实例变量必须要初始化后才能使用。实例变量是实例化后才会分配空间,而静态变量当类加载时会分配空间。

## 是否可以从一个 static 方法内部发出对非 static 方法的调用？

不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对 象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一 个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以， 一个 static 方法内部发出对非 static 方法的调用。

非static方法可以访问static方法.

static方法不能访问非static方法

## "=="和 equals 方法究竟有什么区别？

==如果判断值类型的话，判断内容是否相同。如果判断引用类型则是判断内存地址是否相同

Equals\*******\*判断值内容是否相等

## Integer与int的区别

Integer 是引用类型,默认值是null。而int是是值类型默认值是0

## 请说出作用域public，private，protected，以及不写时的区别

这四个作用域的可见范围如下表所示。

说明：如果在修饰的元素上面没有写任何访问修饰符，则表示 friendly。

作用域 当前类 同一包（package） 子孙类 其他包（package）

public\****   ***\*√        √                    √         √

protected\**√       √                    √         ×

friendly\***√       √                    ×         ×

private   ***√        ×                  ×          ×\***

## 重载与重写区别？

重载是同一个类中，方法名称相同， 但是参数或个数不同。与返回值没有关系。

重写是在多个类中， 产生继承关系。父类与子类的方法方法必须相同。

## 接口与抽象类的区别？

区别:定义接口的关键字是：interface 而定义抽象类的关键字是：abstract。

接口中成员不能有私有， 抽象类可以。

接口中定义的成员， 是finl public static 类型， 抽象类没有。

接口中的不能有普通方法， 抽象类中可以。

相同：

两个都不new

但是 接口与抽象类是面向对象必备知识，设计模式、重构代码有必然作用

## final, finally, finalize 的区别。

final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

内部类要访问局部变量，局部变量必须定义成 final 类型，例如，一段代码……

finally 是异常处理语句结构的一部分，表示总是执行。

finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可

以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 JVM 不保证此方法总被调用

## String、StringBuffer与StringBuilder的区别

String 字符串常量

StringBuffer 字符串变量（线程安全）

StringBuilder 字符串变量（非线程安全）

## 所有的类都继承于object类，你用过的object类的直接子类有哪些，object类常用的方法

有哪些

###### 1．clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

###### 2．getClass方法

final方法，获得运行时类型。

###### 3．toString方法

该方法用得比较多，一般子类都有覆盖。

###### 4．finalize方法

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

###### 5．equals方法

该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

###### 6.数组有没有length()这个方法? String有没有length()这个方法？

答：数组没有length()这个方法，有length的属性。String有length()这个方法。

 

###### 7．hashCode方法

该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

###### 8．wait方法

wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

###### 9．notify方法

该方法唤醒在该对象上等待的某个线程。

###### 10．notifyAll方法

该方法唤醒在该对象上等待的所有线程

## 反射的优缺点？

反射：就是正在运行动态读取这个类的完整信息。

优点：java的反射机制就是增加程序的灵活性、

缺点：缺点：（1）性能问题：使用反射基本上是一种解释操作，

用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用。

（2）使用反射会模糊程序内内部逻辑：程序员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。

那些地方用到了反射？

例如: jdbc、Java常用框架、jdk的动态代理、android的加载布局文件

## java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承， 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？

  字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于

InputStreamReaderOutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提

高性能和使用方便。